---
title: "TakeHomeEx3"
author: "Lin Lin"
format: html
editor: visual
---

## Objective definition:

FishEye International, a non-profit focused on countering illegal, unreported, and unregulated (IUU) fishing, has been given access to an international finance corporation's database on fishing related companies. In the past, **FishEye has determined that companies with anomalous structures are far more likely to be involved in IUU** (or other "fishy" business). FishEye has transformed the database into a knowledge graph. It includes information **about companies, owners, workers, and financial status.** FishEye is aiming to use this graph to identify anomalies that could indicate a company is involved in IUU.

FishEye analysts have attempted to use **traditional node-link visualizations and standard graph analyses, but these were found to be ineffective because the scale and detail in the data can obscure a business's true structure.**

*The research below aim to **help FishEye develop a new visual analytics approach to better understand fishing business anomalies**.*

We will use visual analytics to understand patterns of groups in the knowledge graph and highlight anomalous groups.

Task 1: Use visual analytics to identify anomalies in the **business groups** present in the knowledge graph.

Task 2: Develop a visual analytics process to **find similar businesses and group them**. This analysis should focus on a business's most important features and present those features clearly to the user.

```{r background information}
  #Steps planning
  # 1. Load and process knowledge graph Data
  # 1.1 Data Cleaning, handling missing value, transforming data, select desired columns

  # 2. Focus on Fish related companies
  #Since we are going to focus on fishing business anomalies, we will need to filter out the subset of data relate to fishing activities.  We have to do a bit of text sensing
  ## 2.1 Word tokenization for business key activity extraction, then filter for fishing related only
  ## 2.2. Transform the business relationship by counting company to company, company to owner, company to contact information etc,  categorize relationship manually, give some labels
  # Then among the business groups, we can do exploratory analysis on the relationship, explore those with top number of connections

  # 3. Visualizing pattern of groups
  # 3.1 Apply clustering algorithms to identify groups of related entities within the knowledge graph. Use techniques such as community detection algorithms (e.g., Louvain algorithm) to detect clusters.
  # 3.2 Visualize the identified groups using appropriate visualizations, such as a network graph or a dendrogram, to understand the patterns and relationships among the groups.

  # 4. Identifying anomalies in business groups:

   #4.1 Try to define anomaly detection metrics based on known characteristics of IUU fishing companies. Can consider things like the number of connections, financial transactions, or unusual ownership structures.
  # Calculate the anomaly scores for each business group based on the defined metrics. Use appropriate statistical techniques or anomaly detection algorithms like Isolation Forest or Local Outlier Factor. R packages like anomalyDetection and outliers can be used for this purpose.

  # 5. Measuring similarity and expressing confidence in groupings:

  # Calculate similarity scores or distances between businesses within each group using appropriate similarity measures, such as cosine similarity or Euclidean distance.
  # Visualize the similarity measures to express confidence in the groupings. May use Heatmaps or dendrograms
 
```

## 1. Data Pre-processing and cleaning

Load the library and read the json relationship file MC2.

```{r loadData}
  #echo | false
  #tidytext -- text mining library with R: https://cran.r-project.org/web/packages/tidytext/vignettes/tidytext.html
  #Load Libraries   
  pacman::p_load(jsonlite,tidygraph, ggraph, visNetwork, tidyverse, shiny, plotly, graphlayouts, ggforce, tidytext,skimr)   
  #load Data   
  MC3<- fromJSON("data/MC3.json")
```

### Data Cleaning for MC3 Nodes and Edges

We picked the desired fields and reorganized the columns **using select function.** The nodes in MC3 will be companies or person, and description about companies, with their product and services, country and revenue generated.

As we load the data, we found this diagram is **not directed**, so we will not know the in/out direction of connection.

Below code **extract out nodes** out for further processing.

```{r extractNodes}

  #glimpse(MC3)
  MC3_nodes <- as_tibble(MC3$nodes)
  colSums(is.na(MC3_nodes))

  #Extract and mutate the format so it's not list but dataframe
  MC3_nodes_clean <- MC3_nodes %>% mutate(country = as.character(country),
                                          id = as.character(id),
                                          product_services = as.character(product_services),
                                          revenue_omu = as.numeric(as.character(revenue_omu)),    #we need to convert to numeric directly
                                          type = as.character(type)) %>%
    select(id, country, type, revenue_omu, product_services)

```

The original data do not have NA value, however by transforming data into table format, some fields are NA.

```{r nodesExplore}
  #check data quality, find missing value
  colSums(is.na(MC3_nodes_clean))
  #check which are the types?
  unique(MC3_nodes_clean$type)
  skim(MC3_nodes_clean)
```

Out of the total Nodes 21515 out of 27622 rows **do not have value for revenue_omu.** The ratio of missing value in revenue_omu is 77.9%. **We will need to deal with this Missing values.** And there are 22929 out of 27622 rows have unique ids, **there are duplicates with id. The** ratio of non-duplicate id is 83.0%.

Remove duplicates in nodes: If two rows with duplicate id but with different value in any other 4 columns (country, type, revenue_omu, product_services), keep both rows the duplicate id. If the two rows are identical for all columns, we remove the duplicate row.

```{r nodeRemoveDuplicate}
  #check which are the duplicate ids
  duplicate_ids <- MC3_nodes_clean[duplicated(MC3_nodes_clean$id), "id"]

  #use R base function duplicate to achieve this
  MC3_nodes_clean <- MC3_nodes_clean[!duplicated(MC3_nodes_clean), ]

  DT::datatable(MC3_nodes_clean)
  
```

After removing duplicates, around 2000 rows has been removed, out of the total 4693 duplicate ids.

Below code **extract out edges** out for further processing.

```{r extractEdges}
  
  MC3_edges <- as_tibble(MC3$links) %>% 
  distinct() %>%
  mutate(source = as.character(source),
         target = as.character(target),
         type = as.character(type)) %>%
  group_by(source, target, type) %>%
    summarise(weights = n()) %>%
  filter(source!=target) %>%
  ungroup()
    
  #check missing value
  colSums(is.na(MC3_edges))
  skim(MC3_edges)
```

There is no missing value in edges data. Explore the dataset.

```{r edgeExplore}
  #check which are the types?
  unique(MC3_edges$type)
  
  
  MC3_edges_clean <- MC3_edges %>% mutate(source = as.character(source),
                       target = as.character(target),
                       edgeType = as.character(type)) %>%
  group_by(source, target, edgeType) %>%
  summarise(weights = n()) %>%
  filter(source!=target) %>%
  ungroup()
  
  #datatable() of DT package is used to display mc3_edges tibble data frame as an interactive table on the html document.
  
  DT::datatable(MC3_edges_clean)
```

#### What are the types for edge and nodes?

From the exploration above, we know there are **3 node type possible: Company, Company Contacts, Beneficial Owner**, and there are **2 edge type possible: Company Contacts, Beneficial Owner**

Below plot shows the proportion of each type in node and edge respectively.

In order to find the business group, we will check the type of different category of data. There might be owner - business, customer - business, business - business relationship

```{r typeDistribution}
  ggplot(data = MC3_nodes_clean,
         aes(x= type)) +
    geom_bar()+
  labs(title = "Node Types Distribution",
       x = "Node Types",
       y = "Count")
  
  ggplot(data = MC3_edges_clean,
       aes(x = edgeType)) +
    geom_bar() +
  labs(title = "Edge connection Types Distribution",
       x = "Edge Types",
       y = "Count")
```

Assumption: in this case, we will assume Node type = **Company**, indicating the node is a **legal entity**, while node type = **Company Contacts, Beneficial Owner,** the node is a **natural person**

#### Check source and target types mapping

From edge file, first we explore if there's any mapping information in node for each of the source and target item

```{r sourceAndTargetTypeDataScan}
   
  # Count the number of targets in MC3_edges_clean that exist in MC3_nodes_clean
  existing_targets_count <- MC3_edges_clean %>%
  mutate(target = as.character(target)) %>%
  semi_join(select(MC3_nodes_clean, id), by = c("target" = "id")) %>%
  summarise(targets_found = n_distinct(target))
  print(existing_targets_count)
  
  # Count the number of sources in MC3_edges_clean that exist in MC3_nodes_clean
  existing_sources_count <- MC3_edges_clean %>%
  mutate(source = as.character(source)) %>%
  semi_join(select(MC3_nodes_clean, id), by = c("source" = "id")) %>%
  summarise(sources_found = n_distinct(source))
  print(existing_sources_count)

```

There were sources id found in node file but no target id was found at all. Looking into the edge data, the targets seems are all person's name, hence the in the edge table, the **edgeType should be the target type.**

```{r joinSourceTypeData}

  # Consolidate node information and add source node types, target node type will not be found from node join. Edge type is treated as the target type
  MC3_edges_clean_Join <- MC3_edges_clean %>%
  mutate(source = as.character(source),
         target = as.character(target),
         edgeType = as.character(edgeType)) %>%
  left_join(select(MC3_nodes_clean, id, sourceNodeType = type), by = c("source" = "id")) %>%
  group_by(source, target, sourceNodeType, edgeType) %>%
  summarise(weights = n()) %>%
  filter(source != target) %>%
  ungroup()


  # Plot the stacked bar chart
  ggplot(data = MC3_edges_clean_Join, aes(x = sourceNodeType, fill = edgeType)) +
  geom_bar() +
  labs(title = "Source Node Types with Breakdown of EdgeType",
       x = "Source Types",
       y = "Count") +
  scale_fill_discrete(name = "EdgeType")+
    coord_flip()
  
  
```
They are some observations of source type from benefit owner/company contacts to target type of benefit owner/company contacts.
By right all sources should be company.

For source type of company, we may obtain additional company information mainly from Node (Revenue, Product/Services), and people related information can be obtained from Edge (Edge Type). We can use this to  derive a new nodes data frame from edges data frame.



## 2.Derive New Node Data, Building network model with tidygraph

```{r deriveNewNodeData}
  id1 <- MC3_edges_clean %>%
  select(source) %>%
  rename(id = source)

  id2 <- MC3_edges_clean %>%
    select(target) %>%
    rename(id = target)

    MC3_nodes1 <- rbind(id1, id2) %>%
    distinct() %>%
    left_join(MC3_nodes_clean,
              unmatched = "drop")
  #The unmatched = "drop" argument specifies that any rows from the left data frame (id1 and id2) that do not have a match in the right data frame (MC3_nodes_clean) should be dropped from the result.
  
  
```
There are rows with only id but no type information,  for the "type" column in MC3_nodes1 that is empty, we can potentially fill them with corresponding values from MC3_edges_clean because it provide target node types.

```{r fillInTargetType}
  empty_type_rows <- MC3_nodes1 %>%
  filter(is.na(type))

  # filled_nodes <- empty_type_rows %>%
  # left_join(MC3_edges_clean, by = c("id" = "target")) %>%
  # filter(!is.na(edgeType)) %>%
  # select(id, edgeType) %>%
  # rename(type = edgeType)

  filled_nodes <- empty_type_rows %>%
  left_join(MC3_edges_clean, by = c("id" = "target")) %>%
  select(id, edgeType) %>%
  rename(targetType = edgeType)%>%
  filter(!is.na(targetType))
  
  
  # MC3_nodes2 <- MC3_nodes1 %>%
  # anti_join(empty_type_rows, by = "id") %>%
  # bind_rows(filled_nodes)
  
  # MC3_nodes2 <- MC3_nodes1 %>%
  # left_join(filled_nodes, by = "id")

  MC3_nodes2 <- MC3_nodes1 %>%
  left_join(filled_nodes, by = "id") %>%
  mutate(type = ifelse(is.na(type), targetType, type)) %>%
  select(id, country, type, revenue_omu, product_services)
  
```

```{r calculateGraphWithBetweenness}
  mc3_graph <- tbl_graph(nodes = MC3_nodes2,
                       edges = MC3_edges_clean,
                       directed = FALSE) %>%
  mutate(betweenness_centrality = centrality_betweenness(),
         closeness_centrality = centrality_closeness())
```

```{r networkModelWithBetweenessCentrality}
  graph <- mc3_graph %>%
  filter(betweenness_centrality >= 100000) %>%
  ggraph(layout = "nicely") +
    geom_edge_link(aes( colour = edgeType)) +
    geom_node_point(aes(
      size = betweenness_centrality,
      colour  = type,
      alpha=0.5)) +
    scale_size_continuous(range=c(1,10))+
    theme_graph()

  # visNetwork(MC3_nodes1, MC3_edges_clean, width = "100%")
```

#### Consolidate counting information

With the above knowledge graph, we are interested to know
1. companies vs. owner count, for each company, how many owner does it have?
2. companies vs. company contacts, for each company, how many contacts does it have?
3. owners vs. companies, which are the owners that owns multiple companies?

After that we could categorize relationship manually, give them some labels

```{r statisticsOfRelationship}
  # Counting Beneficial Owner and Company Contacts for each company
  company_counts <- MC3_edges_clean %>%
  filter(edgeType %in% c("Beneficial Owner", "Company Contacts")) %>%
  group_by(source, edgeType) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = edgeType, values_from = count, values_fill = 0)

  # Counting companies owned by each Beneficial Owner
  owner_counts <- MC3_edges_clean %>%
    filter(edgeType == "Beneficial Owner") %>%
    group_by(target) %>%
    summarise(numOfCompanyOwned = n_distinct(source))

  # Update the nodes with the count information
  MC3_nodes_updated <- MC3_nodes2 %>%
    left_join(company_counts, by = c("id" = "source")) %>%
    left_join(owner_counts, by = c("id" = "target"))

 
```


### Text sensing with tidytext

#### word count
Below is a simple word count to understand how many companies has fishing related acitivied, by simply counting occurrence of "fish".

```{r simpleWordCount}
  #start a bit of text sensing, display the result by max value first

  MC3_nodes1 <- MC3_nodes1 %>% 
  mutate(n_fish = str_count(product_services, "fish")) %>%
  arrange(desc(n_fish))

  library(ggplot2)
  ggplot(data = MC3_nodes1, aes(x = n_fish)) +
  geom_histogram(bins=20, 
                 boundary = 20,
                 color="grey25", 
                 fill="grey90") +
  ggtitle("Distribution of keyword Fish frequency") 
  
  ggplot(data = MC3_nodes1, aes(x = type, y = revenue_omu)) +
  geom_bar(stat = "identity")

```

### Tokenisation

We then do tokenization of the Product_Services In text sensing, tokenisation is the process of **breaking up a given text** into units called tokens. We will discard characters like punctuation marks in this progress.

The two basic arguments to unnest_tokens() used here are column names. First argument is **the output column name** that will be created as the text is unnested into it, and then the **input column that the text comes from** (product_services, in this case).

```{r tokenization}
  nodesToken <- MC3_nodes_clean %>%
  unnest_tokens (word, product_services)
  #can add in to_lower = TRUE
  # add in strip_punct = TRUE

```

Below code visualize the distribution of tokenized words for prodct_service
```{r visualizeTextSensingWord}
  nodesToken %>%
  count(word, sort = TRUE) %>%
  top_n(30) %>%
  mutate(word = reorder(word, n)) %>%
  ggplot(aes(x = word, y = n)) +
  geom_col() +
  xlab(NULL) +
  coord_flip() +
      labs(x = "Count",
      y = "Unique words",
      title = "Count of unique words found in product_services field")
```

With above we saw the top frequently sensed word may not be useful, not in our interest. For example, NA, "a" and "to". We will need to remove these words as stop words.

#### Remove stopwords and custom words
From the token generated, we need to take out the common/generic words and we will also exclude NA records, and there are some words obviously doesn't relate to fish activity such as machines, transportations etc. We can remove them as well.

```{r stopwordsRemove}
  custom_stopwords <- c("unknown", "machines", "transportation", "products","related", "services", "including", "systems", "equipment", "materials", "steel", "shoes", "accessories", "logistics", "footwear", "chemicals", "metal")

  tidy_stopwords <- nodesToken %>%
  anti_join(stop_words)%>%
  anti_join(tibble(word = custom_stopwords)) %>%
  na.omit()
```

### Visualization with bar chart after remove stopword
With this visualization, we can detect none fishing related high frequency token and remove it by updating condition in last step.
By several rounds of refinement, below is the diagram that have mostly fishing related keywords:

```{r removeStopWordPlot}
  tidy_stopwords %>%
  count(word, sort = TRUE) %>%
  top_n(30) %>%
  mutate(word = reorder(word, n)) %>%
  ggplot(aes(x = word, y = n)) +
  geom_col() +
  xlab(NULL) +
  coord_flip() +
      labs(x = "Count",
      y = "Unique words",
      title = "Count of unique words found in product_services field")
    
```

Try to get a list of companies with desired keywords

```{r selectedMaritimeCompanies}
  # Define your desired special words
 desired_words <- c("fish", "seafood", "frozen", "food", "fresh", "salmon", "freight", "canned", "meat", "tuna", "shrimp", "shellfish", "sea", "squid", "seafoods", "marine", "fillets", "foods")

  # Filter the companies that contain the desired special words
  filtered_companies <- subset(nodesToken, grepl(paste(desired_words, collapse = "|"), id, ignore.case = TRUE))
  
  filtered_nodes <- nodesToken %>%
  filter(word %in% desired_words) %>%
  distinct(id)
  

```

```{r parallelcordinate}
    #use parallel cordinate to visualize

  # library(cluster)
  # library(caret)
  # 
  # MC3_nodes <- MC3_nodes %>%
  # select(product_services, country, revenue_omu, type) %>%
  # na.omit()
  # 
  # 
  # 
  # #prepare data
  # clustering_data <- MC3_nodes[, c("product_services", "revenue_omu", "type")]
  # #try K means clustering
  # k <- 4  # Number of clusters
  # set.seed(123)  # For reproducibility
  # kmeans_result <- kmeans(clustering_data, centers = k)
  # 
  # MC3_nodes$cluster <- as.factor(kmeans_result$cluster)
  # cluster_summary <- aggregate(clustering_data, by = list(cluster = MC3_nodes$cluster), FUN = mean)
  # 
  # 
  # 
  # pacman::p_load(GGally, parallelPlot)
  # library(GGally)
  # ggparcoord(MC3_nodes[, c("product_services", "country", "revenue_omu", "type","cluster")], 
  #          columns = 1:3, groupColumn = "cluster", 
  #          title = "Parallel Coordinate Plot: Features by Cluster")
  # 
  
```

## ploting relationship?

TODO - failed need troubleshoot

```{r graphobject}
  # GraphMC3 <- tbl_graph(nodes = MC3_nodes_clean,
  #                       edges = MC3_edges_clean,
  #                          directed = FALSE)
  # #
  # GraphMC3
  #is_connected <- is.connected(GraphMC2)
  
  # peopleEntityRelationship %>%
  # activate(edges) %>%
  # arrange(desc(weightkg))
```






##USE THIS LATER??
**Handling missing values:** for some or the product/services, there's blank value such as "character(0)", **recode these value to NA these value before pass them for text sensing**.:

![](images/Issue%20in%20data.JPG)

After these, for the rows where product_services and both revenue_omu columns are NA, and the type is not "Company", this node is less useful as it's not fishing related activity, and it's not providing any company related information.

```{r NA fields}
  # # Recode "character(0)" to NA in the product_services column
  # MC3_nodes_clean$product_services[MC3_nodes_clean$product_services == "character(0)"] <- NA
  # 
  # MC3_nodes_test <- MC3_nodes_clean %>%
  # filter(!(is.na(product_services) & is.na(revenue_omu) & type != "Company"))
  # 
  # # Count the number of sources in MC3_edges_clean that exist in MC3_nodes_clean
  # existing_sources_count1 <- MC3_edges_clean %>%
  # mutate(source = as.character(source)) %>%
  # semi_join(select(MC3_nodes_test, id), by = c("source" = "id")) %>%
  # summarise(sources_found = n_distinct(source))
  # print(existing_sources_count1)

```